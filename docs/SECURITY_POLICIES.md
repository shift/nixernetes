# Multi-Tier Application: Security Policies Reference

This document shows the security policies automatically generated by Nixernetes for the multi-tier application.

## Network Policies

### Default Deny (Implicit)

All ingress and egress traffic is denied by default. Only explicit rules allow communication.

### Allowed Network Flows

```
Frontend (Nginx) [Port 80, 443]
├─ ◄── Ingress Controller (TLS termination)
└─ ──► API Gateway [Port 8080]

API Gateway [Port 8080]
├─ ◄── Frontend (via reverse proxy)
├─ ──► PostgreSQL [Port 5432]
├─ ──► Redis [Port 6379]
├─ ──► RabbitMQ [Port 5672]
└─ ──► Prometheus [Port 9090] (metrics)

PostgreSQL [Port 5432]
└─ ◄── API Gateway (read/write)

Redis [Port 6379]
└─ ◄── API Gateway (cache operations)

RabbitMQ [Port 5672]
└─ ◄── API Gateway (message operations)
       Admin UI [Port 15672] ◄── kubectl port-forward only

Prometheus [Port 9090]
├─ ◄── API Gateway (scrape metrics)
├─ ◄── PostgreSQL exporter
├─ ◄── Redis exporter
└─ ◄── RabbitMQ exporter

Grafana [Port 3000]
├─ ◄── Ingress Controller (public access)
└─ ──► Prometheus [Port 9090]
```

### Generated NetworkPolicy Resources

**Frontend Ingress**:
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: frontend-allow-ingress
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: frontend
  policyTypes:
  - Ingress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
    ports:
    - protocol: TCP
      port: 80
    - protocol: TCP
      port: 443
```

**Frontend Egress**:
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: frontend-allow-egress
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: frontend
  policyTypes:
  - Egress
  egress:
  # Allow DNS
  - to:
    - namespaceSelector: {}
    ports:
    - protocol: UDP
      port: 53
  # Allow to API Gateway
  - to:
    - podSelector:
        matchLabels:
          app: api-gateway
    ports:
    - protocol: TCP
      port: 8080
```

**API Gateway Ingress**:
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: api-gateway-allow-ingress
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: api-gateway
  policyTypes:
  - Ingress
  ingress:
  # From Frontend
  - from:
    - podSelector:
        matchLabels:
          app: frontend
    ports:
    - protocol: TCP
      port: 8080
  # From Prometheus (metrics scraping)
  - from:
    - podSelector:
        matchLabels:
          app: prometheus
    ports:
    - protocol: TCP
      port: 9090
```

**API Gateway Egress**:
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: api-gateway-allow-egress
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: api-gateway
  policyTypes:
  - Egress
  egress:
  # Allow DNS
  - to:
    - namespaceSelector: {}
    ports:
    - protocol: UDP
      port: 53
  # Allow to PostgreSQL
  - to:
    - podSelector:
        matchLabels:
          app: postgres
    ports:
    - protocol: TCP
      port: 5432
  # Allow to Redis
  - to:
    - podSelector:
        matchLabels:
          app: redis
    ports:
    - protocol: TCP
      port: 6379
  # Allow to RabbitMQ
  - to:
    - podSelector:
        matchLabels:
          app: rabbitmq
    ports:
    - protocol: TCP
      port: 5672
```

**Database Ingress**:
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: postgres-allow-ingress
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: postgres
  policyTypes:
  - Ingress
  ingress:
  # From API Gateway
  - from:
    - podSelector:
        matchLabels:
          app: api-gateway
    ports:
    - protocol: TCP
      port: 5432
```

**Database Egress**:
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: postgres-allow-egress
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: postgres
  policyTypes:
  - Egress
  egress:
  # Allow DNS
  - to:
    - namespaceSelector: {}
    ports:
    - protocol: UDP
      port: 53
  # Allow metrics to Prometheus
  - to:
    - podSelector:
        matchLabels:
          app: prometheus
    ports:
    - protocol: TCP
      port: 9090
```

## RBAC Configuration

### ServiceAccounts

Each component has its own service account with minimal permissions:

```yaml
# API Gateway needs to read secrets from ExternalSecrets
apiVersion: v1
kind: ServiceAccount
metadata:
  name: api-gateway
  namespace: production
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: api-gateway
  namespace: production
rules:
- apiGroups: [""]
  resources: ["configmaps", "secrets"]
  verbs: ["get", "list"]
  resourceNames: ["api-gateway-config", "api-gateway-secrets"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: api-gateway
  namespace: production
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: api-gateway
subjects:
- kind: ServiceAccount
  name: api-gateway
  namespace: production
```

### ExternalSecrets Operator Role

If using ExternalSecrets:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: external-secrets-operator
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["create", "update", "patch"]
- apiGroups: ["external-secrets.io"]
  resources: ["externalsecrets"]
  verbs: ["get", "watch", "list"]
- apiGroups: ["external-secrets.io"]
  resources: ["secretstores", "clustersecretstores"]
  verbs: ["get", "watch", "list"]
```

## Pod Security Standards

### Restricted Policy

All pods comply with Kubernetes Pod Security Standards "Restricted" level:

```yaml
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: restricted
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
  - ALL
  volumes:
  - 'configMap'
  - 'emptyDir'
  - 'projected'
  - 'secret'
  - 'downwardAPI'
  - 'persistentVolumeClaim'
  hostNetwork: false
  hostIPC: false
  hostPID: false
  runAsUser:
    rule: 'MustRunAsNonRoot'
  seLinux:
    rule: 'MustRunAs'
    seLinuxOptions:
      level: "s0:c123,c456"
  fsGroup:
    rule: 'MustRunAs'
    ranges:
    - min: 1
      max: 65535
  readOnlyRootFilesystem: true
```

## Secret Management

All sensitive data is managed via Vault with ExternalSecrets:

### ExternalSecrets Resources

```yaml
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: vault-backend
  namespace: production
spec:
  provider:
    vault:
      server: "https://vault.internal:8200"
      path: "secret"
      auth:
        kubernetes:
          mountPath: "kubernetes"
          role: "production-role"
---
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: api-gateway-secrets
  namespace: production
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: vault-backend
    kind: SecretStore
  target:
    name: api-gateway-secrets
    creationPolicy: Owner
  data:
  - secretKey: db-password
    remoteRef:
      key: app/postgres
  - secretKey: api-key
    remoteRef:
      key: app/api
  - secretKey: jwt-secret
    remoteRef:
      key: app/security
```

### Vault Paths

```
secret/
├── database/
│   └── postgres
│       └── password: <random>
├── app/
│   ├── postgres
│   │   ├── username: app_user
│   │   └── password: <random>
│   ├── api
│   │   └── key: <random>
│   └── security
│       └── jwt_secret: <random>
├── messaging/
│   └── rabbitmq
│       └── password: <random>
└── monitoring/
    └── grafana
        └── admin_password: <random>
```

## Compliance Labels

All resources labeled with compliance metadata:

```yaml
labels:
  nixernetes.io/framework: "SOC2"
  nixernetes.io/compliance-level: "strict"  # or "standard"
  nixernetes.io/owner: "platform-eng"
  nixernetes.io/data-classification: "confidential"  # or "internal"
  app.kubernetes.io/name: "<component>"
  app.kubernetes.io/version: "<version>"
  app.kubernetes.io/component: "<role>"
  app.kubernetes.io/part-of: "production-app"
  app.kubernetes.io/managed-by: "nixernetes"
```

## Audit Logging

### Kubernetes Audit Policy

```yaml
apiVersion: audit.k8s.io/v1
kind: Policy
rules:
# Log all requests at RequestResponse level
- level: RequestResponse
  verbs: ["create", "update", "patch", "delete"]
  resources:
  - group: ""
    resources: ["secrets", "configmaps"]
  namespaces: ["production"]
  
# Log pod exec and port-forward
- level: RequestResponse
  verbs: ["create"]
  resources:
  - group: ""
    resources: ["pods/exec", "pods/portforward"]
  namespaces: ["production"]

# Default: log at Metadata level
- level: Metadata
```

### Application Audit Trail

Each pod includes traceability annotations:

```yaml
annotations:
  nixernetes.io/nix-build-id: "<commit-hash>"
  nixernetes.io/generated-by: "nixernetes"
  nixernetes.io/deployment-date: "<ISO8601>"
```

## Security Scanning

### Container Image Scanning

Images should be scanned with:

```bash
# Trivy
trivy image myregistry/myapp:v1.0

# Snyk
snyk container test myregistry/myapp:v1.0

# Grype
grype myregistry/myapp:v1.0
```

### Dependency Scanning

Dependencies should be checked:

```bash
# npm
npm audit

# Python
pip install safety
safety check

# Ruby
bundle audit
```

## Security Checklist for Production

- [ ] All NetworkPolicies deployed and tested
- [ ] RBAC roles follow least-privilege principle
- [ ] Pod Security Standards enforced
- [ ] Secrets encrypted in transit (TLS)
- [ ] Secrets encrypted at rest (etcd)
- [ ] Vault access restricted to required pods
- [ ] Container images scanned and signed
- [ ] Network policies allow only required flows
- [ ] No pod runs as root (uid 0)
- [ ] Root filesystem is read-only
- [ ] Capabilities dropped
- [ ] Compliance labels applied to all resources
- [ ] Audit logging enabled and monitored
- [ ] Security scanning integrated into CI/CD

## Verification Commands

```bash
# Verify network policies are enforced
kubectl -n production get networkpolicies

# Test network policy (should fail)
kubectl -n production exec <api-gateway-pod> -- \
  wget -O- http://grafana:3000

# Verify RBAC
kubectl -n production get roles,rolebindings

# Check pod security
kubectl -n production get pods -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.spec.securityContext}{"\n"}{end}'

# Verify no pods running as root
kubectl -n production get pods -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.spec.containers[0].securityContext.runAsUser}{"\n"}{end}'

# Check secret encryption
kubectl get secrets -n production -o jsonpath='{.items[0].metadata}'

# View audit logs
kubectl logs -n kube-system -l component=kube-apiserver | grep audit
```

## References

- [Kubernetes Network Policies](https://kubernetes.io/docs/concepts/services-networking/network-policies/)
- [RBAC Authorization](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)
- [Pod Security Standards](https://kubernetes.io/docs/concepts/security/pod-security-standards/)
- [External Secrets Operator](https://external-secrets.io/)
- [Vault Documentation](https://www.vaultproject.io/docs)
- [OWASP Kubernetes Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Kubernetes_Security_Cheat_Sheet.html)
